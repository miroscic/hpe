/*
  ____                                   _             _       
 / ___|  ___  _   _ _ __ ___ ___   _ __ | |_   _  __ _(_)_ __  
 \___ \ / _ \| | | | '__/ __/ _ \ | '_ \| | | | |/ _` | | '_ \ 
  ___) | (_) | |_| | | | (_|  __/ | |_) | | |_| | (_| | | | | |
 |____/ \___/ \__,_|_|  \___\___| | .__/|_|\__,_|\__, |_|_| |_|
                                  |_|            |___/         
# A Template for HpePlugin, a Source Plugin
# Generated by the command: C:\Program Files\MADS\usr\local\bin\mads-plugin.exe -t source -d C:\mirrorworld\hpe -i C:\Program Files\MADS\usr\local\bin hpe
# Hostname: unknown
# Current working directory: C:\mirrorworld
# Creation date: 2025-07-14T13:40:38.376+0200
# NOTICE: MADS Version 1.3.1
*/

// Mandatory included headers
#include <source.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/opencv.hpp>
#include <string>

#include <pcl/console/parse.h>
#include <pcl/io/pcd_io.h>
#include <pcl/visualization/pcl_visualizer.h>

#include <Eigen/Dense>
#include <models/hpe_model_openpose.h>
#include <models/input_data.h>
#include <openvino/openvino.hpp>
#include <pipelines/async_pipeline.h>
#include <pipelines/metadata.h>
#include <utils/common.hpp>

#ifdef __linux
#include <lccv.hpp> // for Raspi
#endif

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "hpe"
#endif

#ifdef _WIN32
#define _USE_MATH_DEFINES
#include <cmath>
#endif

#ifdef KINECT_AZURE
#pragma message("This computer has the Kinect Azure SDK installed.")
// include Kinect libraries
#include <k4a/k4a.h>
#include <k4a/k4a.hpp>
#include <k4abt.hpp>
#endif

// Load the namespaces
using namespace cv;
using namespace std;
using namespace std::chrono;
using json = nlohmann::json;

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "hpe"
#endif

typedef float data_t;

struct color_point_t {
  int16_t xyz[3];
  uint8_t rgb[3];
};

// Map of OpenPOSE keypoint names

map<int, string> keypoints_map_openpose = {
  {0, "NOS_"},  {1, "NEC_"},  {2, "SHOR"},  {3, "ELBR"},  {4, "WRIR"},
  {5, "SHOL"},  {6, "ELBL"},  {7, "WRIL"},  {8, "HIPR"},  {9, "KNER"},
  {10, "ANKR"}, {11, "HIPL"}, {12, "KNEL"}, {13, "ANKL"}, {14, "EYER"},
  {15, "EYEL"}, {16, "EARR"}, {17, "EARL"}};

map<int, string> keypoints_map_azure = {
  {27, "NOS_"}, {3, "NEC_"},  {12, "SHOR"}, {13, "ELBR"}, {14, "WRIR"},
  {5, "SHOL"},  {6, "ELBL"},  {7, "WRIL"},  {22, "HIPR"}, {23, "KNER"},
  {24, "ANKR"}, {18, "HIPL"}, {19, "KNEL"}, {20, "ANKL"}, {30, "EYER"},
  {28, "EYEL"}, {31, "EARR"}, {29, "EARL"}};


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class HpePlugin : public Source<json> {

  /*
    ____  _        _   _                                 _
   / ___|| |_ __ _| |_(_) ___   _ __ ___   ___ _ __ ___ | |__   ___ _ __ ___
   \___ \| __/ _` | __| |/ __| | '_ ` _ \ / _ \ '_ ` _ \| '_ \ / _ \ '__/ __|
    ___) | || (_| | |_| | (__  | | | | | |  __/ | | | | | |_) |  __/ |  \__ \
   |____/ \__\__,_|\__|_|\___| |_| |_| |_|\___|_| |_| |_|_.__/ \___|_|  |___/

  */



  /*
    __  __      _   _               _
   |  \/  | ___| |_| |__   ___   __| |___
   | |\/| |/ _ \ __| '_ \ / _ \ / _` / __|
   | |  | |  __/ |_| | | | (_) | (_| \__ \
   |_|  |_|\___|\__|_| |_|\___/ \__,_|___/

  */

public:

  // Constructor
  HpePlugin() : _agent_id(PLUGIN_NAME) {}

  // Destructor
  ~HpePlugin() {}

  /**
   * @brief Acquire a frame from a camera device. Camera ID is defined in the
   * parameters list.
   *
   * The acquired frame is stored in the #_k4a_rgbd, #_rgbd and #_rgb
   * attributes.
   *
   * @see set_params
   * @author Nicola
   * @return result status ad defined in return_type
   */
  return_type acquire_frame(bool dummy = false) {

    cout << "Acquiring frame..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Compute the skeleton from the depth map.
   *
   * Compute the skeleton from the depth map. The resulting skeleton is stored
   * in #_skeleton3D attribute as a map of 3D points.
   *
   * @author Nicola
   * @return result status ad defined in return_type
   */
  return_type skeleton_from_depth_compute(bool debug = false) {

    cout << "Computing skeleton from depth..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Remove unnecessary points from the point cloud
   *
   * Make the point cloud lighter by removing unnecessary points, so that it
   * can be sent to the database via network
   *
   * @author Nicola
   * @return result status ad defined in return_type
   */
  return_type point_cloud_filter(bool debug = false) {

    cout << "Filtering point cloud..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Transform the 3D skeleton coordinates in the global reference frame
   *
   * Use the extrinsic camera parameters to transorm the 3D skeleton coordinates
   * just before sending them as plugin output.
   *
   * @return return_type
   */
  return_type coordinate_transform(bool debug = false) {
    
    cout << "Transforming coordinates..." << endl;

    return return_type::success;
  }

  /**
   * @brief Compute the skeleton from RGB images only
   *
   * Compute the skeleton from RGB images only. On success, the field
   * #_skeleton2D is updated (as a map of 2D points).
   * Also, the field #_heatmaps is updated with the joints heatmaps (one per
   * joint).
   *
   * There is a configuration flag for optionally skipping this branch
   * on Azure agents.
   *
   * @author Alessandro
   * @return result status ad defined in return_type
   */
  return_type skeleton_from_rgb_compute(bool debug = false) {

    cout << "Computing skeleton from RGB..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Compute the hessians for joints
   *
   * Compute the hessians for joints on the RGB frame based on the #_heatmaps
   * field.
   *
   * @author Alessandro
   * @return result status ad defined in return_type
   */
  return_type hessian_compute(bool debug = false) {

    cout << "Computing hessians..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Compute the 3D covariance matrix
   *
   * Compute the 3D covariance matrix.
   * Two possible cases:
   *   1. one Azure camera: use the 3D to uncertainty in the view axis, use
   *      the 2D image to uncertainty in the projection plane
   *   2. one RGB camera: calculates a 3D ellipsoid based on the 2D covariance
   *      plus the "reasonable" depth range as a third azis (direction of view)
   *
   * @author Alessandro
   * @return result status ad defined in return_type
   */
  return_type cov3D_compute(bool debug = false) {

    cout << "Computing 3D covariance..." << endl;
    
    return return_type::success;
  }

  /**
   * @brief Consistency check of the 3D skeleton according to human physiology
   *
   * @authors Marco, Matteo
   * @return result status ad defined in return_type
   */
  return_type consistency_check(bool debug = false) {

    cout << "Performing consistency check..." << endl;
    
    return return_type::success;
  } 

  return_type viewer(bool debug = false) {

    cout << "Launching viewer..." << endl;
    
    return return_type::success;
  }

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type get_output(json &out, std::vector<unsigned char> *blob = nullptr) override {

    out.clear();

    out["agent_id"] = _agent_id;
    out["ts"] = std::chrono::duration_cast<std::chrono::nanoseconds>(_start_time.time_since_epoch()).count();

    if (acquire_frame(_dummy) == return_type::error) {
      return return_type::error;
    }

    if (skeleton_from_depth_compute(
            _params["debug"]["skeleton_from_depth_compute"]) ==
        return_type::error) {
      return return_type::error;
    }

    if (point_cloud_filter(_params["debug"]["point_cloud_filter"]) ==
        return_type::error) {
      return return_type::error;
    }
    
    if (skeleton_from_rgb_compute(
            _params["debug"]["skeleton_from_rgb_compute"]) ==
        return_type::error) {
      return return_type::error;
    }

    if (hessian_compute(_params["debug"]["hessian_compute"]) ==
        return_type::error) {
      return return_type::error;
    }

    if (cov3D_compute(_params["debug"]["cov3D_compute"]) ==
        return_type::error) {
      return return_type::error;
    }
        
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }

  void set_params(void const *params) override {
 
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    map<string, string> info;
    info["kind"] = kind();
    info["model_file"] = _model_file;
    return info; 
  };

protected:

  Mat _rgbd;          /**< the last RGBD frame */
  Mat _rgb;           /**< the last RGB frame */
  Mat _rgbd_filtered; /**< the last RGBD frame filtered with the body index mask*/

  map<string, vector<unsigned char>> _skeleton2D; /**< the skeleton from 2D cameras only*/
  map<string, vector<float>> _skeleton3D;       /**< the skeleton from 3D cameras only*/
  map<string, Eigen::Matrix3f> _cov3D; /**< the 3D covariance matrix */      
  
  vector<Mat> _heatmaps; /**< the joints heatmaps */
  Mat _point_cloud;      /**< the filtered body point cloud */

  std::vector<Eigen::Matrix2f> _cov2D_vec; /**< the 2D covariance matrix vector */
  std::vector<Eigen::Matrix3f> _cov3D_vec; /**< the 3D covariance matrix vector */
  json _params;   /**< the parameters of the plugin */

};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SOURCE_DRIVER(HpePlugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  HpePlugin plugin;
  json output, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Process data
  plugin.get_output(output);

  // Produce output
  cout << "Output: " << output << endl;

  return 0;
}
